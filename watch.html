<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>DiscuAnime - Watch</title>
  <style>
    body { font-family: sans-serif; background: #111; color: #eee; padding: 10px; }
    iframe { width: 100%; height: 480px; border: none; border-radius: 8px; background: #000; margin-bottom: 10px; }
    select, button { padding: 6px; margin: 5px 0; border-radius: 4px; border: none; }
    #log { background: #222; padding: 10px; font-size: 12px; white-space: pre-wrap; height: 200px; overflow: auto; margin-top: 10px; border-radius: 8px; }
    .hidden { display: none; }
  </style>
</head>
<body>

<h1>üé¨ Watch Anime</h1>
<iframe id="videoPlayer" src=""></iframe>

<div>
  <label>√âpisode:</label>
  <select id="episodeSelector"></select>

  <label>Lecteur:</label>
  <select id="lecteurSelector"></select>

  <button onclick="playSelected()">‚ñ∂Ô∏è Lancer</button>
</div>

<div id="log">[ Logs chargement... ]</div>

<script>
const log = (msg) => {
  document.getElementById("log").textContent += "\n‚Üí " + msg;
};

const getParam = (name) => {
  const params = new URLSearchParams(window.location.search);
  return params.get(name) || "";
};

async function fetchEpisodeScript() {
  const animeSlug = getParam("V");
  const lang = getParam("lang") || "vf";

  const basePaths = [
    `https://anime-sama.fr/catalogue/${animeSlug}/saison1/${lang}/episodes.js`,
    `https://anime-sama.fr/catalogue/${animeSlug}/film/${lang}/episodes.js`,
  ];

  for (const path of basePaths) {
    const proxiedURL = `https://corsproxy.io/?${path}`;
    log(`üîÑ Chargement de: ${proxiedURL}`);

    try {
      const res = await fetch(proxiedURL);
      const scriptText = await res.text();
      log(`üì¶ Script r√©cup√©r√©, parsing √† la main...`);

      const regex = /var\s+(eps\d+)\s*=\s*(\[[\s\S]*?\]);/g;
      const matchMap = new Map();
      let m;
      while ((m = regex.exec(scriptText))) {
        try {
          const array = JSON.parse(m[2].replace(/'/g, '"').replace(/,\s*]/g, ']'));
          matchMap.set(m[1], array);
        } catch (err) {
          log(`‚ö†Ô∏è JSON parse √©chou√© pour ${m[1]}: ${err.message}`);
        }
      }

      if (matchMap.size > 0) return matchMap;

    } catch (err) {
      log(`‚ùå Erreur chargement: ${err.message}`);
    }
  }

  log("‚ùå Erreur: Aucun √©pisode valide trouv√©");
  return null;
}

function testLecteur(url, timeout = 5000) {
  return new Promise((resolve) => {
    const iframe = document.createElement("iframe");
    iframe.style.display = "none";
    iframe.src = url;

    let settled = false;

    const finish = (ok) => {
      if (!settled) {
        settled = true;
        iframe.remove();
        resolve(ok);
      }
    };

    iframe.onload = () => finish(true);
    iframe.onerror = () => finish(false);
    document.body.appendChild(iframe);

    setTimeout(() => finish(false), timeout);
  });
}

async function loadAndFilter() {
  const episodeMap = new Map();
  const lecteurs = await fetchEpisodeScript();
  if (!lecteurs) return;

  let total = 0;
  for (const [lecteur, urls] of lecteurs) {
    for (let i = 0; i < urls.length; i++) {
      const epNum = i + 1;
      const url = urls[i];
      total++;
      log(`‚è≥ Test lecteur ${lecteur} - √©pisode ${epNum}...`);
      const ok = await testLecteur(url);
      if (!ok) {
        log(`‚õî Lecteur HS: ${lecteur} - √©pisode ${epNum}`);
        continue;
      }
      log(`‚úÖ ${lecteur} - √©pisode ${epNum} trouv√©`);
      if (!episodeMap.has(epNum)) episodeMap.set(epNum, []);
      episodeMap.get(epNum).push({ lecteur, url });
    }
  }

  if (episodeMap.size === 0) {
    log("‚ùå Aucun lecteur valide trouv√©.");
    return;
  }

  log(`‚úÖ ${total} lecteurs test√©s. ${episodeMap.size} √©pisode(s) disponible(s).`);
  fillSelectors(episodeMap);
}

function fillSelectors(episodeMap) {
  const epSelect = document.getElementById("episodeSelector");
  const lecteurSelect = document.getElementById("lecteurSelector");

  for (const epNum of [...episodeMap.keys()].sort((a, b) => a - b)) {
    const opt = document.createElement("option");
    opt.value = epNum;
    opt.textContent = `√âpisode ${epNum}`;
    epSelect.appendChild(opt);
  }

  epSelect.onchange = () => {
    lecteurSelect.innerHTML = "";
    const epNum = parseInt(epSelect.value);
    const lecteurs = episodeMap.get(epNum) || [];
    lecteurs.forEach((entry, i) => {
      const opt = document.createElement("option");
      opt.value = i;
      opt.textContent = `${entry.lecteur}`;
      lecteurSelect.appendChild(opt);
    });
  };

  epSelect.value = [...episodeMap.keys()][0];
  epSelect.dispatchEvent(new Event("change"));
  playSelected(episodeMap);
}

function playSelected(map = null) {
  const epNum = parseInt(document.getElementById("episodeSelector").value);
  const lecteurIdx = parseInt(document.getElementById("lecteurSelector").value);
  const lecteurs = map ? map.get(epNum) : null;

  const url = lecteurs
    ? lecteurs[lecteurIdx]?.url
    : currentEpisodes.get(epNum)?.[lecteurIdx]?.url;

  if (url) {
    document.getElementById("videoPlayer").src = url;
    log(`‚ñ∂Ô∏è Lecture √©pisode ${epNum}, lecteur ${lecteurIdx + 1}`);
  } else {
    log(`‚ùå Aucun lecteur valide pour cet √©pisode`);
  }
}

window.onload = () => {
  loadAndFilter();
};
</script>

</body>
</html>
