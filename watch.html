<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Watch Anime</title>
  <style>
    body { font-family: sans-serif; background: #111; color: #fff; margin: 0; padding: 10px; }
    #logs { background: #222; padding: 10px; font-size: 12px; max-height: 200px; overflow: auto; white-space: pre-wrap; border: 1px solid #444; }
    select, button { font-size: 14px; margin: 5px; }
    iframe { width: 100%; height: 360px; border: none; margin-top: 10px; }
  </style>
</head>
<body>
  <h2>üé• Lecture Anime</h2>
  <div>
    <label>Langue : </label>
    <select id="langSelect"></select>
    <label>√âpisode : </label>
    <select id="episodeSelect"></select>
    <label>Lecteur : </label>
    <select id="playerSelect"></select>
  </div>
  <iframe id="videoFrame" src=""></iframe>
  <div id="logs">[ Logs chargement... ]</div>

  <script>
    const log = msg => logs.textContent += '\n‚Üí ' + msg;

    const params = new URLSearchParams(location.search);
    const title = params.get("V");
    const langParam = params.get("lang") || "vf,vostfr,vo";
    const langs = langParam.split(',').map(l => l.trim().toLowerCase());
    const langPriority = ['vf', 'vostfr', 'vo'];
    const selectedLang = langPriority.find(l => langs.includes(l)) || langs[0];

    const epSelect = document.getElementById("episodeSelect");
    const playerSelect = document.getElementById("playerSelect");
    const videoFrame = document.getElementById("videoFrame");
    const langSelect = document.getElementById("langSelect");

    let allData = {}; // { lang: { eps1: [...], eps2: [...], ... } }
    let currentLang = selectedLang;
    let currentEps = "eps1";
    let currentPlayers = [];

    langs.forEach(l => {
      let opt = document.createElement("option");
      opt.value = l;
      opt.textContent = l.toUpperCase();
      if (l === selectedLang) opt.selected = true;
      langSelect.appendChild(opt);
    });

    langSelect.onchange = () => {
      currentLang = langSelect.value;
      loadEpisodesUI(currentLang);
    };

    async function fetchScript(url) {
      try {
        log(`üîÑ Chargement de: ${url}`);
        const res = await fetch("https://corsproxy.io/?" + url);
        const txt = await res.text();
        log("üì¶ Script r√©cup√©r√©, parsing √† la main...");
        return txt;
      } catch (e) {
        log("‚ùå Erreur de chargement");
        return null;
      }
    }

    function extractEpisodeLinks(scriptText) {
      const regex = /var (eps\d+) = \[(.*?)\];/gs;
      let result = {};
      let match;
      while ((match = regex.exec(scriptText)) !== null) {
        const epVar = match[1];
        const links = match[2].split(",").map(l => l.trim().replace(/^["']|["']$/g, '')).filter(Boolean);
        if (!result[epVar]) result[epVar] = [];
        result[epVar].push(...links);
        log(`‚úÖ ${epVar} - ${links.length} lecteur(s) trouv√©(s)`);
      }
      return result;
    }

    async function testLink(url, timeout = 3000) {
      try {
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), timeout);
        await fetch("https://corsproxy.io/?" + url, { signal: controller.signal, method: "HEAD" });
        clearTimeout(timer);
        return true;
      } catch {
        return false;
      }
    }

    async function loadEpisodes(lang) {
      const base = `https://anime-sama.fr/catalogue/${title}/`;
      const tries = [`saison1/${lang}/episodes.js`, `film/${lang}/episodes.js`];
      for (const path of tries) {
        const fullURL = base + path;
        const txt = await fetchScript(fullURL);
        if (txt) {
          const data = extractEpisodeLinks(txt);
          if (Object.keys(data).length) return data;
        }
      }
      return {};
    }

    async function loadEpisodesUI(lang) {
      epSelect.innerHTML = "";
      playerSelect.innerHTML = "";
      currentPlayers = [];

      const data = allData[lang];
      if (!data) return;

      const episodes = Object.keys(data).sort((a, b) => {
        return parseInt(a.replace("eps", "")) - parseInt(b.replace("eps", ""));
      });

      episodes.forEach(epsKey => {
        const num = epsKey.replace("eps", "");
        const opt = document.createElement("option");
        opt.value = epsKey;
        opt.textContent = `√âpisode ${num}`;
        epSelect.appendChild(opt);
      });

      epSelect.onchange = () => {
        currentEps = epSelect.value;
        updatePlayers();
      };

      currentEps = episodes[0];
      epSelect.value = currentEps;
      updatePlayers();
    }

    async function updatePlayers() {
      const links = allData[currentLang][currentEps] || [];
      currentPlayers = [];

      playerSelect.innerHTML = "";

      for (let i = 0; i < links.length; i++) {
        const isValid = await testLink(links[i]);
        if (isValid) {
          currentPlayers.push(links[i]);
          const opt = document.createElement("option");
          opt.value = i;
          opt.textContent = `Lecteur ${i + 1}`;
          playerSelect.appendChild(opt);
        }
      }

      if (currentPlayers.length > 0) {
        videoFrame.src = currentPlayers[0];
        playerSelect.onchange = () => {
          const id = parseInt(playerSelect.value);
          videoFrame.src = currentPlayers[id];
        };
        log(`‚ñ∂Ô∏è Lecture auto de l'√©pisode ${currentEps.replace("eps", "")} - Lecteur 1`);
      } else {
        videoFrame.src = "";
        log("‚ùå Aucun lecteur valide trouv√©");
      }
    }

    (async () => {
      for (const l of langs) {
        const data = await loadEpisodes(l);
        if (Object.keys(data).length > 0) {
          allData[l] = data;
          log(`‚úÖ Episodes charg√©s pour ${l.toUpperCase()}`);
        } else {
          log(`‚ùå Aucun √©pisode trouv√© pour ${l.toUpperCase()}`);
        }
      }

      loadEpisodesUI(currentLang);
    })();
  </script>
</body>
</html>
